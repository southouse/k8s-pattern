# 예측 범위 내의 요구사항 패턴
- 물리적으로 필요한 런타임 환경 의존성이나 자원 요구사항과 상관 없이 애플리케이션 요구사항을 선언하는 방법에 관한 것

## 문제
- 언어에 따라 각기 요구사항이 다르기 마련
- 컨테이너가 최적의 기능을 수행하는 데 필요한 자원량을 예측하기 어려움
  - 개발자가 테스트한 뒤에 서비스 구현을 위한 자원량을 알 수 있는 서비스
  - 고정된 CPU 값이나 메모리 소비 프로파일을 가진 서비스
  - 스파이크를 치는 서비스
- 데이터 저장을 위한 영구 스토리지가 필요한 서비스
- 호스트 서버에 고정된 특정 포트 번호를 사용해야 제대로 작동하는 레거시 서비스

> 모든 애플리케이션 특성을 정의하고 이를 관리 플랫폼으로 전달하는 것은 클라우드 네이티브 애플리케이션의 기본 전제조건

## 해결책
- 컨테이너 런타임 요구사항을 알아야 하는 이유

  1. 모든 런타임 의존성이 정의되고 자원 요구사항이 계산되면, 가장 효율적인 하드웨어 사용을 위해 클러스터 내에 컨테이너 실행 위치를 지능적으로 결정이 가능
  2. 필요한 자원량을 예측하게 되면, 다양한 환경에 대한 용량 계획을 세우고, 전체 클러스터에 대한 요구사항을 충족하는 비용 효율이 높은 최적의 호스트 프로파일을 만들 수 있음

### 런타임 의존성
- 애플리케이션의 상태를 저장하는 파일 스토리지 (`file-storage/`)
  - 컨테이너 파일 시스템은 일시적이며 컨테이너가 종료되면 삭제
  - 파드를 다시 시작한 후에도 볼륨을 유지하려면, 다른 종류의 스토리지 메커니즘을 지원하는 볼륨을 사용
    - 노드의 볼륨을 사용하는 `hostPath`, AWS 클라우드 환경의 EBS, EFS 등
  - 클러스터 노드가 제공하지 않는 볼륨을 파드가 필요로 하면, 파드는 스케줄링되지 않음
- 호스트 시스템의 특정 포트로 컨테이너 포트 노출
  - `hostPort`는 클러스터에서 각 노드에 해당 포트를 예약하고 노드 하나당 최대 하나의 파드만 스케줄링되게 제한
  - 포트 충돌 때문에 쿠버네티스 클러스터 노드 수만큼만 파드를 확장 가능
- 애플리케이션의 설정 의존성 (`configmap/`)
  - 쿠버네티스에선 `configmap` 오브젝트를 이용해 설정
  - 애플리케이션은 환경 변수 혹은 파일 시스템 내의 파일을 통한 설정이 있음
  - `Secret` 오브젝트로 좀 더 안전한 방법을 제공
- 스토리지와 포트 번호 의존성은 파드가 스케줄링되는 위치를 제한
- 컨피그맵과 시크릿 의존성은 파드를 시작하는 것을 제한

> 이러한 의존성을 갖는 컨테이너화된 애플리케이션을 설계할 때는 향후 발생하게 될 런타임 제약사항을 항상 고려

### 자원 프로파일 (`resources/`)
- CPU나 네트워크 대역폭처럼 제어가 가능한 압축 가능 자원(compressible resource)과 메모리와 같이 제어 불가능한 압축 불가능 자원(incompressible resource)로 분류
- 압축 가능 자원을 너무 많이 소비하면 병목현상이 발생
- 압축 불가능 자원을 너무 많이 소비하면 컨테이너가 셧다운
- 애플리케이션의 특성과 세부 구현사항에 근거해 필요한 최소 자원량과 사용량의 증가 한도인 최대 자원량을 항상 지정해야 함
- 최소 자원량(request)나 최대 자원량(limit) 혹은 둘 모두를 기술하느냐에 따라 여러 종류의 서비스 품질(QoS, Quality of Service)를 제공
  - Best-Effort 파드
    - 요청과 제한을 갖고 있지 않는 파드
    - 가장 낮은 우선순위
    - 압축 불가능 자원이 전부 사용되어 없어지면 가장 먼저 셧다운
  - Burstable 파드
    - 요청과 제한을 모두 갖고 있으면서, 서로의 값이 다른 파드
    - 압축 불가능 자원에 대해 압박을 받는 경우, Best-Effort 파드가 남아있지 않다면 셧다운될 확률이 높음
  - Guaranteed 파드
    - 요청과 제한이 동일한 파드
    - 가장 높은 우선순위

> 컨테이너에 대한 요청과 제한 값은 QoS에 직접적인 영향을 미치고, 셧다운의 우선순위에도 영향을 미치기 때문에 이런 사항을 고려해 파드 자원 요구사항을 결정해야 함

### 파드 우선순위 (`priority/`)
> 책을 쓰는 시점엔 beta, 현재(2023-08-28)은 정식 버전으로 `scheduling.k8s.io/v1` 으로 설정
- 다른 파드와 비교해 상대적인 파드의 중요성을 지정하며 파드가 스케줄링 되는 순서에 영향을 미침
- 파드 우선순위 기능이 활성화되면 스케줄러가 파드를 노드에 배치하는 순서에 영향을 미침
  
  1. 우선순위 어드미션 컨트롤러(Priority Admission Controller)는 `priorityClassName` 필드를 사용해 새로운 파드의 우선순위 값을 채움
  2. 다수의 파드가 배치되기를 기다리는 경우 스케줄러는 보류 중인 파드들이 저장된 큐에서 우선순위가 가장 높은 파드를 맨 처음에 오도록 정렬
  3. 다른 스케줄링 제약사항이 없다면 선택된 그 파드는 바로 스케줄링
- 파드를 배치하기에 충분한 용량을 가진 노드가 없다면 스케줄러는 자원을 확보하고 우선순위가 높은 파드를 배치하기 위해 실행되고 있는 우선순위가 낮은 파드를 제거
- 해당 알고리즘을 통해 클러스터 관리자는 더 중요한 워크로드 파드를 효과적으로 제어하고 우선순위가 낮은 축출(eviction)해 워커노드에 공간을 확보
- `kubelet`은 파드를 축출하기 전에 먼저 QoS를 고려하고 다음에 PriorityClass를 고려
- 반면 스케줄러 축출 로직은 선점 대상을 선택할 때 파드의 서비스 품질을 완전히 무시

### 프로젝트 자원
- 리소스쿼터(ResourceQuota)
  - 네임스페이스 안에서 컴퓨팅 자원, 스토리지의 전체 사용량, 컨피그맵, 시크릿, 파드, 서비스 같은 객체의 총 개수를 제한할 수 있음
- 리미트레인지(LimitRange)
  - 각 자원 종류마다 최대 자원량을 설정
  - 여러 자원 종류에 대한 최소 및 최대 허용량과 기본 값도 지정 가능
  - 요청과 제한의 비율을 제어할 수 있음
  - 특정 네임스페이스에 리미트레인지를 설정한 경우 컨테이너에 요청/제한 값을 지정하지 않으면 기본 값으로 자동 설정

### 용량 계획
- 하드웨어를 최적으로 활용하려면, Best-Effort와 Burstable 컨테이너를 주로 사용
- 안정적이고 예측 가능하길 원하면, Guaranteed와 약간의 Burstable 컨테이너를 사용

> 자원 프로파일을 식별해 컨테이너의 성공적인 용량 계획을 세우고 모든 애플리케이션은 자원 선언(요청/제한)을 염두에 두고 제공해야 함