# 자동 배치
> 컨테이너 자원 요청을 만족하고 스케줄링 정책을 준수하는 노드에 신규 파드를 할당해주는 기능

## 문제
- 점점 더 많은 수로 늘어가는 마이크로서비스를 개별적으로 노드에 할당하고 배치하는 것은 관리하기 어려운 작업
- 컨테이너는 서로 간의 의존성, 컨테이너와 노드 간의 의존성, 자원 요구사항, 시간에 따른 변경사항을 가짐
- 클러스터에서 사용 가능한 자원은 시간이 지남에 따라, 클러스터를 확장/축소함에 따라, 이미 배치된 컨테이너가 자원을 소비함에 따라 다양하게 변함

> 컨테이너를 배치하는 방법은 가용성, 성능뿐만 아니라 분산 시스템의 용량에도 영향을 미침

## 해결책
- 스케줄러는 다른 쿠버네티스 컴포넌트(API 서버, 큐블릿)과 비슷하게, 하나의 독립 프로세스로 실행될 수 있거나, 전혀 사용되지 않을 수 있음
- 스케줄러가 수행하는 주요 작업은 API서버로부터 새로 생성된 파드 정의를 조회하고 파드를 노드에 할당하는 것
- 스케줄러는 초기 애플리케이션 배치, 스케일 업, 비정상 노드에서 정상 노드로 이동할 때 등 언제든 모든 파드에 대해 적절한 노드를 찾음
- 스케줄러 작업은 런타임 의존성, 자원 요구사항, 고가용성 가이드 정책에 대한 고려, 파드의 수평 확장, 상호 호출 시 성능 및 낮은 지연 시간을 위한 파드들의 가까운 배치 등을 통해 수행

> 스케줄러가 스케줄링 작업을 정확하게 수행하고 선언적 배치를 가능하게 하려면 가용한 용량을 확보한 노드와 선언된 자원 프로파일 및 가이드 정책을 갖춘 컨테이너가 필요

### 가용한 노드 자원
- 모든 노드에는 파드를 실행할 수 있는 용량이 있고, 스케줄러는 파드가 요청한 자원의 총합이 할당 가능한 노드의 용량보다 작다는 것을 확인해야 함
- 노드의 용량을 계산할 때는 아래의 공식을 이용
  ```
  애플리케이션 파드에 대한 용량(Allocatable) = 
  하나의 노드에 가용한 용량(Node Capacity)
   - 큐블릿, 컨테이너 런타임 같은 쿠버네티스 데몬(Kube-Reserved)
    - sshd, udev 같은 OS 시스템 데몬(System-Reserved)
  ```
- OS와 쿠버네티스를 관리하는 데몬의 자원을 예약하지 않으면, 파드와 시스템 데몬이 서로 자원을 사용하겠다고 경쟁하여 노드에 자원 부족 문제를 일으킬 수 있음
- 이런 제한에 대한 임시적 해결 방법은 아무 일도 하지 않는 플레이스홀더(placeholder) 파드를 실행하는 것
  - 관리되지 않는 컨테이너의 자원 사용량과 일치하는 CPU와 메모리에 대한 자원 요청이 있음
  - 추적되지 않는 컨테이너의 자원 소비를 나타내거나 예약하기 위해서만 생성

### 컨테이너 자원 요구
- 컨테이너가 런타임 의존성과 자원 요구 정의(request와 limit)를 갖는 것
- 올바른 선언으로 파드가 현명하게 노드에 할당되고 피크 타임 동안 서로 영향 없이 실행될 수 있음

### 배치(Placement) 정책
- 올바른 필터를 가지거나 특정 애플리케이션 요구에 대해 우선순위 정책에 대한 것
- 스케줄러 정책과 사용자정의 스케줄러는 오직 관리자만이 클러스터 설정으로 정의할 수 있음
- 스케줄러 정책 예제
  ```json
  {
    "Kind": "Policy",
    "apiVersion": "v1",
    "predicates": [
        {"name": "PodFitsHostPorts"},
        {"name": "PodFitsResources"},
        {"name": "NoDiskConflict"},
        {"name": "NoVolumeZoneConflict"},
        {"name": "MatchNodeSelector"},
        {"name": "HostName"}
    ],
    "priorities": [
        {"name": "LeastRequestedPriority", "weight": 2},
        {"name": "BalanceResourceAllocation", "weight": 1},
        {"name": "ServiceSpreadingPriority", "weight": 2},
        {"name": "EqualPriority", "weight": 1},
    ]
  }
  ```
- 기본 스케줄러 정책을 설정하는 것 외에도 다중 스케줄러를 띄워서 파드를 특정 스케줄러에 지정해 배치할 수 있음
  - 파드 명세에 `spec.schedulerName`를 사용

### 스케줄링 프로세스
- 파드부터 노드까지의 할당 프로세스
  ![Alt text](image.png)
- 노드에 할당되지 않은 파드가 생성되는 즉시, 곧바로 스케줄러는 할당 가능한 모든 노드 그리고 필터링 정책과 우선순위 정책 세트와 함께 해당 파드를 선택
  
  1. 필터링 정책을 적용하고, 파드 조건에 기초해 자격 없는 모든 노드를 제거
  2. 남은 노드는 가중치에 의해 정렬
  3. 파드가 노드에 할당

- 대부분의 경우 파드부터 노드까지의 할당 작업은 스케줄러에게 맡기는 것이 좋고, 배치로직을 세세하게 관리하지 않는 편이 나음
- 일부 경우에서는 파드를 특정 노드나 노드 그룹에 강제로 할당하길 원할 수 있음
  - 노드 셀렉터(Node Selector)를 사용
  - 노드에 레이블로 존재하는 키/값 쌍의 맵이 지정되어야 함
  - 노드에 사용자 정의 레이블을 지정하는 것 외에도 모든 노드에 있는 일부 기본 레이블을 이용할 수 있음
    - `kubernetes.io/hostname` 레이블을 이용해 파드를 호스트명으로 노드에 배치할 때 사용
    - OS와 아키텍쳐, 인스턴스 타입을 나타내는 또 다른 기본 레이블도 배치에 유용하게 사용될 수 있음

### 노드 어피니티
- 필수(required) 혹은 선호(preferred)라는 규칙을 지정할 수 있음
  - 필수 규칙은 파드가 노드에 스케줄링되기 위해 반드시 충족되어야 함
  - 선호 규칙은 반드시 충족되어야 하는 것은 아니고 일치하는 노드의 가중치를 증가시켜 노드가 선택하게 함
- `In`, `NotIn`, `Exists`, `DoesNotExist`, `Gt`, `Lt`와 같은 연산자를 활용해 표현 가능
- `nodeSelector`로는 충분하지 않을 때 선택

### 파드 어피니티와 파드 안티어피니티
- 고가용성을 위해 파드를 분산시키는 방법을 표현하거나, 지연 시간 개선을 위해 파드를 함께 배치하는 방법을 표현하기 위해 파드 어피니티(pod affinity)와 파드 안티어피니티(pod antiaffinity)를 사용
- `topologyKey` 필드를 설정하여 노드 레이블의 키 값을 지정하여 노드의 범위를 결정할 수 있음
  - ex. 특정 노드 단위(topologyKey: kubernetes.io/hostname), 가용 영역 단위(topologyKey: topology.kubernetes.io/zone), 리전 단위(topologyKey: topology.kubernetes.io/region) 등
- 노드의 레이블이 바뀌고 어피니티 규칙이 더 이상 유효하지 않아도 파드가 계속 실행은 되지만, 향후 런타임으로 변경되는 것도 고려 대상
  - 노드 레이블이 바뀌고 스케줄되지 않은 파드가 노드 어피니티 셀렉터와 일치하면 해당 파드는 노드에 스케줄링 됨

### 테인트(Taint)와 톨러레이션(Toleration)
- 테인트와 톨러레이션은 파드가 스케줄되어야 하는지 혹은 스케줄되지 말아야 하는지를 노드가 제어하게 허용
  - 노드 어피니티는 파드가 노드를 선택할 수 있는 속성
- 테인트는 노드의 속성이고, 파드가 테인트에 대한 톨러레이션이 없다면 해당 노드에 스케줄링 될 수 없음
- 테인트 종류
  - 하드(hard) 테인트: 노드에 스케줄링을 금지 (effect=NoSchedule)
  - 소프트(soft) 테인트: 가능한 노드에 스케줄링을 피하게 함 (effect=PreferNoSchedule)
  - 축출 테인트: 이미 실행 중인 파드를 노드로부터 축출 (effect=NoExecute)
- 애플리케이션의 고가용성과 성능 요구사항에 기초해 배치(placement)에 영향을 줄 수 있지만, 스케줄러에 많은 제약을 가해서 파드가 더 이상 스케줄링되지 못하고 자원은 너무 많이 남겨지는 상황을 조심해야 함
- 새로운 파드가 스케줄링 되는 그 시점의 클러스터에 기초하기 때문에, 클러스터가 유동적이거나 노드의 자원 프로파일이 변하거나 새로운 노드가 추가돼도 스케줄러는 이전 파드 배치를 수정하지 않음

> 이에 대한 내용은 쿠버네티스 디스케줄러(descheduler)에 의해 해결될 수 있음

### 디스케줄러(descheduler)
- `DeschedulerPolicy` 형태의 쿠버네티스 오브젝트 (현재 alpha 테스트 단계)
- 디스케줄러 전략
  - `RemoveDuplicates`
    - 레플리카셋이나 디플로이먼트와 관련된 하나의 파드를 하나의 노드에만 실행
    - 둘 이상의 파드가 있으면 초과 파드는 제거
    - 노드가 비정상상태가 되었을 때, 관리 컨트롤러가 다른 정상 노드에 새로운 파드를 실행시키는 시나리오에 유용
  - `LowNodeUtilization`
    - 활용률이 과도하게 높은 노드의 파드를 제거하여 활용률이 낮은 노드에 파드를 배치
    - 자원을 분산시키고 효율적으로 사용할 수 있게 만듦
    - thresholds 값으로 활용률이 낮거나 높은 노드를 탐색
  - `RemovePodsViolatingInterPodAntiAffinity`
    - 파드 간 안티어피니티 규칙을 위반한 파드를 축출
    - 파드가 노드에 배치된 후에 안티어피니티 규칙이 추가될 때 발생
  - `RemovePodsViolatingNodeAffinity`
    - 노드 어피니티 규칙을 위반한 파드를 축출
- 사용된 정책에 관계 없이 디스케줄러는 다음 파드들을 축출하지 않음
  - `scheduler.alpha.kubernetes.io/critical-pod` 애노테이션으로 표시된 중요한 파드
    - 1.16 버전 이후는 삭제, 대신 `spec.priorityClassName` 사용이 권장
  - 레플리카셋, 디플로이먼트, 잡에 의해 관리되지 않는 파드
  - 데몬셋에 의해 관리되지 않는 파드
  - 로컬 스토리지를 갖는 파드
  - 파드를 축출하면 `PodDisruptionBudget` 규칙을 위반하게 되는 `PodDisruptionBudget`을 사용한 파드
  - 디스케줄 파드 자신
- 모든 축출은 파드의 서비스 품질(QoS) 레벨을 준수

### 정리
- 배치는 되도록 개입을 최소한으로 줄여야 하는 영역
  - 컨테이너의 모든 자원 요구사항을 정확하게 정의했다면 클러스터가 알아서 가장 적절한 노드에 파드를 배치할 것이기 때문
- 자원이 충분하지 않은 경우엔, 원하는 배포 토폴로지로 스케줄러를 조정
- 스케줄링 제어 요약 (버전에 따라 달라질 수 있음)
  - `nodeName`: 노드 이름 지정
  - `nodeSelector`: 노드 레이블(키/값)을 지정
  - [기본 스케줄링 변경(배치 정책 변경)](https://github.com/southouse/k8s-pattern/tree/main/chapter6#%EB%B0%B0%EC%B9%98placement-%EC%A0%95%EC%B1%85): 필요한 경우, 스케줄러의 필터링과 우선순위 정책 목록 순서, 가중치를 변경
  - [파드 어피니티와 안티어피니티](https://github.com/southouse/k8s-pattern/tree/main/chapter6#파드-어피니티와-파드-안티어피니티): 애플리케이션의 지연 요구사항, 고가용성, 보안 제약조건 등과 같은 파드 간의 의존성을 표현
  - [노드 어피니티](https://github.com/southouse/k8s-pattern/tree/main/chapter6/노드-어피니티): 노드의 하드웨어, 위치 등과 같은 파드의 노드에 대한 의존성을 표현
  - [테인트와 톨러레이션](https://github.com/southouse/k8s-pattern/tree/main/chapter6/테인트(Taint)와-톨러레이션(Toleration))
    - 노드는 파드 스케줄링을 제어
    - 파드 그룹에 대한 노드를 지정하거나, 런타임에 파드를 축출할 수 있음
  - 사용자정의 스케줄러

> 컨테이너 자원 프로파일 크기를 정하고, 파드와 노드에 적절하게 레이블을 지정하며 스케줄러에는 개입을 최소한으로 줄여야 함